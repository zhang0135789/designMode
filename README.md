# designMode
软考-设计模式入门
欢迎交流qq群 ： 786937587

23个常用设计模式基础知识

## 23个设计模式
### 创建型
#### demo01_AbstractFactory 抽象工厂模式
    创建型
    抽象工厂模式提供了一个接口，用于创建一系列相关或相互依赖的对象。通过使用抽象工厂接口及其具体实现，可以将对象的创建与客户端代码分离，从而实现系统的松耦合。

#### demo02_FactoryMethod 抽象方法模式
    创建型
    工厂方法模式是一种创建型设计模式，它提供了一种方法来创建对象，而无需将对象的创建逻辑暴露给客户端代码。这种模式有助于将代码的创建和使用分离，从而使代码更加灵活和易于维护。

#### demo03——Prototype 原型设计模式
    创建型
    单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。

#### demo04——Singleton 单例设计模式
    创建型
    单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。

#### demo05——Builder 构建起设计模式
    创建型
    建造者模式（builder pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。**建造者模式适用于构建具有复杂结构的对象，其构建过程较为稳定，但对象的表示需要灵活变化的情况。

### 结构型
#### demo06——Adapter 适配器模式
    结构型
    适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
    类适配器
    对象适配器

#### demo07——Bridge 桥接模式
    结构型
    桥接模式（bridge-pattern）是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立变化而互不影响。桥接模式通过组合的方式，将抽象部分和实现部分分别设计，并通过一个桥接接口（Bridge）将它们连接起来。

#### demo08——Composite 组合模式
    结构型
    组合模式（composite-pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

#### demo09——Decorator 装饰器模式
    结构型
    装饰器模式（decorator-pattern）是一种结构型设计模式，它允许在不改变原有对象结构的情况下，动态地给对象添加新的功能。装饰器模式通过将对象包装在一个装饰器对象中，然后在装饰器对象中添加新的行为，从而实现了对原有对象的功能扩展。

#### demo10——Facade 外观模式
    结构型
    外观模式（facade-pattern）是一种结构型设计模式，它提供了一个统一的接口，用来访问子系统中的一组接口。外观模式的目的是简化客户端与子系统之间的交互，通过封装子系统的复杂性，提供一个更简单的接口给客户端使用。

#### demo11——Flyweight 享元模式
    结构型
    享元模式（flyweight-pattern）是一种结构型设计模式，它通过共享对象来减少内存中对象的数量，从而提高系统的性能和效率。享元模式将对象分为两种：内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象的固有属性，可以共享；外部状态是对象的变化属性，不可以共享。

#### demo12——Proxy 代理模式
    结构型
    代理模式（Proxy Pattern）是一种结构型设计模式，它允许通过一个代理对象来控制对另一个对象的访问。代理模式通常用于在访问对象时添加一些额外的功能，例如权限控制、日志记录等。代理模式将客户端和目标对象解耦，使得客户端可以通过代理对象来访问目标对象。

### 行为性模式

#### demo13——Observe 观察者模式
    行为性
    观察者模式（observer-pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。

#### demo14——Visitor 访问者模式
    行为性
    访问者模式（visitor-pattern）是一种行为设计模式，它主要将数据结构中的元素操作分离出来并封装成独立的类，使得在不改变数据结构的前提下，可以添加作用于这些元素的新的操作。这种模式的核心思想是将数据结构与数据操作分离，从而使得操作集合可以相对自由地演化而不影响数据结构的稳定性。

#### demo15——State 状态模式
    行为性
    状态模式（state-pattern）是一种行为型设计模式，类的行为是基于它的状态改变的。

#### demo16——ChainOfResponsibility 职责链模式
    行为性
    责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它允许多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。责任链模式将请求的发送者和接收者解耦，避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

#### demo17——Command 命令模式
    行为性
    命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而使得请求的发送者和接收者解耦。命令模式允许请求的发送者和接收者之间没有直接的关联关系，而是通过一个命令对象来进行通信。

#### demo18——Interpreter 解释器模式
    行为性
    解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

#### demo19——interator 迭代器模式
    行为性
    迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。

#### demo20——Mediator 中介者模式
    行为性
    中介者模式（Mediator Pattern）是一种行为型设计模式，它用于减少对象之间的直接依赖关系，从而提高系统的灵活性和可维护性。中介者模式通过引入一个中介者对象来协调对象之间的交互，从而使得对象之间不需要直接相互通信，而是通过中介者对象来进行通信。

#### demo21——Memento 备忘录模式
    行为性
    备忘录模式（memento-pattern）是一种设计模式，主要用于在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后需要时能将该对象恢复到原先保存的状态。备忘录模式又叫快照模式，属于行为型模式。

#### demo22——Strategy 策略模式
    行为性
    策略模式（strategy-pattern）是一种行为型设计模式，它允许在运行时根据上下文情况选择算法的行为。在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。

#### demo23——Template 模板方法模式
    行为性
    模板模式（template-pattern）是一种行为性设计模式。在模板模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。







    



